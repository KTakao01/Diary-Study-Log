# done
recursion 上級　木構造　
・木構造の走査
・深さ優先走査(1)
・深さ優先走査(2)
・Quiz7
・前順（二分木）
・間順(二分木)
・後順（二分木）
・後間順（二分木）
・二分木の最大の深さ
・BST「挿入」
・BST「削除」

# report
再帰のアルゴリズム</br>
https://recursionist.io/dashboard/course/3/lesson/467
・中央値を根ノードとする</br>
ソート配列を元に二分探索木を作ってるので、</br>

https://recursionist.io/dashboard/course/3/lesson/466
・ランダムにシャッフルした配列を一つずつ木構造として構築していく。</br>
insert関数は挿入のたびにiterator=rootに設定して、探索して適切な位置を見つける</br>

### 再帰プロセス
https://recursionist.io/dashboard/course/3/lesson/471
Goでは
```
results = postorderTraversalHelper(root.left,results)
    fmt.Println("左探索",results,root.data.value)
    results = postorderTraversalHelper(root.right,results)
    fmt.Println("右探索",results,root.data.value)
    results = append(results,root.data.value)
```
容量を超えると新しい配列が作成され、既存の配列要素が新しい配列にコピーされる。そして新しいスライスが作成される。スライスは配列要素の参照渡しで値を扱っている。

関数に渡すときはGoではスライスの値が（＝ポインタ、長さ、容量）がコピーされて渡される。しかしポインタコンポーネント（スライスは配列の参照）は同じ配列を示すため関数内でのスライスの要素を変更してもその変更は関数の外でも反映される。

例外として関数ないでスライス自体を変更すると、関数外部のスライスには反映されない。戻り値として返し、呼び出し元で受け取らない限り、関数内部で完結する。

```go
package main

import "fmt"

func modifySlice(s []int) {
    s[0] = 100  // これは呼び出し元のスライスに影響します
    s = append(s, 4)  // これは呼び出し元のスライスに影響しません
}

func main() {
    a := []int{1, 2, 3}
    modifySlice(a)
    fmt.Println(a)  // [100 2 3] を出力します
}

```
### ２つの配列を扱うループ
https://recursionist.io/dashboard/problems/275
・２つの配列をひとまとめにして１つのループで計算する。

正答
https://recursionist.io/dashboard/problems/submissions/680036
```go
for i + j < len(results1)+ len(results2) - 2 {
        if results1[i] <= results2[j] {
            merged = append(merged,results1[i])
            i++
        } else {
            merged = append(merged,results2[j])
            j++
        }
    }
```

誤答
https://recursionist.io/dashboard/problems/submissions/680030
・スタック、キューは一つの配列に基づいてその配列の増減や変化を捉えるのに有効。スタックを使うことでループ処理とは別の時間軸を扱える

・基本的に二つの配列をスタックで扱うなら二つスタックいる。

### nilチェック
```go
    var val1, val2 int32
    var left1, right1, left2, right2 *BinaryTree
    
    if root1 != nil && root1.data != nil{
        val1 = root1.data.value
        left1 = root1.left
        right1 = root1.right
    }
    if root2 != nil && root2.data != nil{
        val2 = root2.data.value
        left2 = root2.left
        right2 = root2.right
    }

```

・nilチェックした時だけ値を取得して変数に代入するようにすると、nilでないときは値を取得しない。

### 再帰でbool型を出力する場合
https://recursionist.io/dashboard/problems/submissions/680745
・再帰をreturnで戻す手法
```go
func isSameTree(root1 *BinaryTree, root2 *BinaryTree) bool{
    // 関数を完成させてください
   // 両方のノードがnilの場合
   if root1 == nil && root2 == nil {
        return true
    }

    // 一方のノードだけがnilの場合
    if root1 == nil || root2 == nil {
        return false
    }

    // 両方のノードの値だけがnilでない場合
    if root1.data != nil && root2.data != nil {    
        // ノードの値が異なる場合
        if root1.data.value != root2.data.value {
            return false
        }
    }

    // 再帰的に左と右の子ノードを比較
    return isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right)
}

```