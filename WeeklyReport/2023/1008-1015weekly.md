# done
recursion 上級　木構造　
・木構造の走査
・深さ優先走査(1)
・深さ優先走査(2)
・Quiz7
・前順（二分木）
・間順(二分木)
・後順（二分木）
・後間順（二分木）
・二分木の最大の深さ
・BST「挿入」
・BST「削除」

# report
再帰のアルゴリズム</br>
https://recursionist.io/dashboard/course/3/lesson/467
・中央値を根ノードとする</br>
ソート配列を元に二分探索木を作ってるので、</br>

https://recursionist.io/dashboard/course/3/lesson/466
・ランダムにシャッフルした配列を一つずつ木構造として構築していく。</br>
insert関数は挿入のたびにiterator=rootに設定して、探索して適切な位置を見つける</br>

### 再帰プロセス
https://recursionist.io/dashboard/course/3/lesson/471
Goでは
```
results = postorderTraversalHelper(root.left,results)
    fmt.Println("左探索",results,root.data.value)
    results = postorderTraversalHelper(root.right,results)
    fmt.Println("右探索",results,root.data.value)
    results = append(results,root.data.value)
```
容量を超えると新しい配列が作成され、既存の配列要素が新しい配列にコピーされる。そして新しいスライスが作成される。スライスは配列要素の参照渡しで値を扱っている。

関数に渡すときはGoではスライスの値が（＝ポインタ、長さ、容量）がコピーされて渡される。しかしポインタコンポーネント（スライスは配列の参照）は同じ配列を示すため関数内でのスライスの要素を変更してもその変更は関数の外でも反映される。

例外として関数ないでスライス自体を変更すると、関数外部のスライスには反映されない。戻り値として返し、呼び出し元で受け取らない限り、関数内部で完結する。

```go
package main

import "fmt"

func modifySlice(s []int) {
    s[0] = 100  // これは呼び出し元のスライスに影響します
    s = append(s, 4)  // これは呼び出し元のスライスに影響しません
}

func main() {
    a := []int{1, 2, 3}
    modifySlice(a)
    fmt.Println(a)  // [100 2 3] を出力します
}

```
### ２つの配列を扱うループ
https://recursionist.io/dashboard/problems/275
・２つの配列をひとまとめにして１つのループで計算する。

正答
https://recursionist.io/dashboard/problems/submissions/680036
```go
for i + j < len(results1)+ len(results2) - 2 {
        if results1[i] <= results2[j] {
            merged = append(merged,results1[i])
            i++
        } else {
            merged = append(merged,results2[j])
            j++
        }
    }
```

誤答
https://recursionist.io/dashboard/problems/submissions/680030
・スタック、キューは一つの配列に基づいてその配列の増減や変化を捉えるのに有効。スタックを使うことでループ処理とは別の時間軸を扱える

・基本的に二つの配列をスタックで扱うなら二つスタックいる。

### nilチェック
```go
    var val1, val2 int32
    var left1, right1, left2, right2 *BinaryTree
    
    if root1 != nil && root1.data != nil{
        val1 = root1.data.value
        left1 = root1.left
        right1 = root1.right
    }
    if root2 != nil && root2.data != nil{
        val2 = root2.data.value
        left2 = root2.left
        right2 = root2.right
    }

```

・nilチェックした時だけ値を取得して変数に代入するようにすると、nilでないときは値を取得しない。

### 再帰でbool型を出力する場合
https://recursionist.io/dashboard/problems/submissions/680745
・再帰をreturnで戻す手法
```go
func isSameTree(root1 *BinaryTree, root2 *BinaryTree) bool{
    // 関数を完成させてください
   // 両方のノードがnilの場合
   if root1 == nil && root2 == nil {
        return true
    }

    // 一方のノードだけがnilの場合
    if root1 == nil || root2 == nil {
        return false
    }

    // 両方のノードの値だけがnilでない場合
    if root1.data != nil && root2.data != nil {    
        // ノードの値が異なる場合
        if root1.data.value != root2.data.value {
            return false
        }
    }

    // 再帰的に左と右の子ノードを比較
    return isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right)
}

```

### medium
https://recursionist.io/dashboard/problems/267
mediumで、久々に一瞬で指針を思いつくも実装にやや手間取るパターンで正解した。
理由：実装前に方針の妥当性を検証した。いつも検証しているが今回は解像度を上げた。
思考をクリアにしてシンプルな方針なら必ず解ける。
定義を理解したら初見で方法を思い付かないといけない場合と例題や問題の方針を応用して解ける場合がある
前者は仮説をおもいつかなくて当然の部分が大きい
後者は理解できていれば解けるはず
また定義を問題を通して理解するための問題もあるのでそこでつまるならすぐに答えをみるか定義の理解に勤める。


問題演習について
解法理解したら、復習して暗記に励むよりかは
・解けなかった問題と同程度の難易度の類似問題を解く
・典型的な解法理解の網羅性を高めるためにアルゴリズム本を一通りこなす