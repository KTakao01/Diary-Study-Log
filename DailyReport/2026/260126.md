# paiza

## B136:チョコのお返し

# https://paiza.jp/works/challenges/666/page

```js
process.stdin.resume();
process.stdin.setEncoding("utf8");
// 自分の得意な言語で
// Let's チャレンジ！！
var lines = [];
var reader = require("readline").createInterface({
  input: process.stdin,
  output: process.stdout,
});
reader.on("line", (line) => {
  lines.push(line);
});
reader.on("close", () => {
  const various = lines[0].trim().split(" ");
  const move_sum = Number(various[0]);
  const vert_seat = Number(various[1]);
  const hor_seat = Number(various[2]);
  const my_seats = lines[1].trim().split(" ");
  const my_outer = Number(my_seats[0]) - 1; // ２次元配列上の位置
  const my_inner = Number(my_seats[1]) - 1; // ２次元配列上の位置
  const how_move = lines[2].trim().split("");
  let sec_ar = [];
  // 座席を二次元配列へ
  for (i = 0; i < vert_seat; i++) {
    // i行目のチョコレートをくれる数を取得
    sec_ar.push([]);
    const i_seat = lines[3 + i].trim().split(" ").map(Number);
    for (j = 0; j < hor_seat; j++) {
      // i行目j列目のチョコレートをくれる数を二次元配列へ格納
      sec_ar[i][j] = i_seat[j];
    }
  }
  //   console.log(sec_ar,how_move,my_outer,my_inner)
  // 実際に移動させる
  for (i = 0; i < move_sum; i++) {
    // どの方向へ移動するか
    let cur_outer = my_outer;
    let cur_inner = my_inner;
    let action = how_move[i];
    console.log(action, my_outer, my_inner);
    // 自分の席からどこへ移動するか
    if (action == "F") {
      if (my_outer - 1 >= 0) {
        console.log(sec_ar[cur_outer - 1][cur_inner]);
      } else {
        console.log(0);
      }
    }
    if (action == "B") {
      if (my_outer + 1 >= 0) {
        console.log(sec_ar[cur_outer + 1][cur_inner]);
      } else {
        console.log(0);
      }
    }
    if (action == "L") {
      if (my_inner - 1 >= 0) {
        console.log(sec_ar[cur_outer][cur_inner - 1]);
      } else {
        console.log(0);
      }
    }
    if (action == "R") {
      if (my_inner + 1 >= 0) {
        console.log(sec_ar[cur_outer][cur_inner + 1]);
      } else {
        console.log(0);
      }
    }
  }
});

// 状況整理
// 自分の席は前から2 左から1
// 前
// 2,3
// 0,3
// 1,2
// 後
// ロジック
//　上から前[[2,2],[0,3],[1,2]] 自分の席は配列では1,0
// F : -1,0 B:+1,0 R:0,+1 L:0,-1
//席がない時、if 配列インデックス>0 のみ増減させる

// 時短ポイント：正解したけど迷った
// ・初期化をループ内外どちらに持っていくか
// ・-= 1 を-= -1とした　-1ずつを意図していたのに＋1ずつになってしまう
// ・・
```

## 改善後

```js
process.stdin.resume();
process.stdin.setEncoding("utf8");
// 自分の得意な言語で
// Let's チャレンジ！！
var lines = [];
var reader = require("readline").createInterface({
  input: process.stdin,
  output: process.stdout,
});
reader.on("line", (line) => {
  lines.push(line);
});
reader.on("close", () => {
  const [moveSum, H, W] = lines[0].trim().split(" ").map(Number);

  let [curRow, curCol] = lines[1]
    .trim()
    .split(" ")
    .map((n) => Number(n) - 1);

  const moves = lines[2].trim().split("");

  const grid = lines.slice(3).map((line) => line.trim().split(" ").map(Number));

  const directions = { F: [-1, 0], B: [1, 0], L: [0, -1], R: [0, 1] };

  for (let move of moves) {
    const [dRow, dCol] = directions[move];
    const nextRow = curRow + dRow;
    const nextCol = curCol + dCol;

    if (nextRow >= 0 && nextRow < H && nextCol >= 0 && nextCol < W) {
      curRow = nextRow;
      curCol = nextCol;
      console.log(grid[curRow][curCol]);
    } else {
      console.log(0);
    }
  }
});

// 改善点
// 境界条件が不足していた、ifの条件分岐→オブジェクト、forループ→mapの利用
```
