# paiza B
https://paiza.jp/challenges/485

## 自身の回答（正解）
```js
process.stdin.resume();
process.stdin.setEncoding('utf8');
// 自分の得意な言語で
// Let's チャレンジ！！
var lines = [];
var reader = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});
reader.on('line', (line) => {
  lines.push(line);
});
reader.on('close', () => {
    let current = 0;
    const [N,M] = lines[current++].trim().split(" ").map(Number);
    // let roads = Array.from({length: N},() => Array(N).fill(0));
    let roads = []
    
    //　道路の降水量マップ作成
    for (let i=0; i<N; i++){
      let road = lines[current++].trim().split(" ").map(Number);
      roads.push(road);
    }
    // 1行1 2行1 ３行1が同グループ
    
    // console.log(roads)

    let canRoad = [];
    for (let i=0; i< N; i++){
        let canPass = 0;
        // j (1次元配列の要素)
        for (let j=0; j < N;j++){
            if (roads[j][i] < M){
                // console.log(roads[i][j])
                canPass++
            }
        }
        // console.log(canPass)
        if (canPass == N){
            // console.log(canPass,i)
            canRoad.push(i+1)
        }
    }
    if (canRoad.length == 0){
        console.log("wait");
    }
    console.log(canRoad.join(" "));
});


// 入力例3
// 3 50
// 40 40 40
// 40 40 40
// 40 40 40
// 出力例3
// 1 2 3

// N M
// p_{1,1} p_{1,2} ... p_{1,N} 
// p_{2,1} p_{2,2} ... p_{2,N}
// ...
// p_{N,1} p_{N,2} ... p_{N,N}


// 会社に行くことができる場合は、すべての通ることのできるルートの番号を以下の形式で出力してください。

// r_1 r_2 ...
// ・期待する出力は 1 行からなります。
// ・通ることのできるルートの番号を小さい順に r_1, r_2, ... として、半角スペース区切りで全て出力してください。
// ・末尾に改行を入れ、余計な文字、空行を含んではいけません。
// 自宅待機で良い場合は、
// wait
// と、出力してください。
```

## 改善

```
1. 【重要】出力の分岐処理（余計な空行の防止）
現在のコードの最後にある出力部分ですが、canRoad.length == 0 のときに wait を出力した直後、そのまま下の console.log(canRoad.join(" ")); も実行されてしまいます。
この場合、wait の下の行に「空行（空の文字列の出力）」が入ってしまいます。Paizaは出力のフォーマットに厳密なので、余計な出力が入らないように else でしっかり分岐させるか、return で処理を終わらせるのが安全です。

2. ループの「早期退出（break）」による高速化
現在のコードでは、ある道が「通れない（M以上）」と分かった後も、一番下まで降水量のチェックを続けています。
途中で1箇所でも M 以上の場所があったら、その道はもう通れないことが確定するので、break を使ってその時点でチェックを打ち切ると、無駄な処理が省けて実行速度（解答までの速さ）が上がります。

3. JavaScriptの配列メソッド（.every()）の活用
もしさらにモダンで短いコードを書きたい場合、配列の every() メソッドを使うと for ループを1つ減らすことができ、より直感的なコードになります。
```

```js
process.stdin.resume();
process.stdin.setEncoding('utf8');

var lines = [];
var reader = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});

reader.on('line', (line) => {
  lines.push(line);
});

reader.on('close', () => {
    let current = 0;
    const [N, M] = lines[current++].trim().split(" ").map(Number);
    let roads = [];
    
    // 道路の降水量マップ作成
    for (let i = 0; i < N; i++){
      roads.push(lines[current++].trim().split(" ").map(Number));
    }

    let canRoad = [];
    
    // 列（ルート）ごとの判定
    for (let i = 0; i < N; i++){
        let canPass = true; // 最初は通れると仮定する
        
        for (let j = 0; j < N; j++){
            if (roads[j][i] >= M){
                canPass = false; // 基準値以上の場所が見つかったらフラグを折る
                break; // そのルートはもう調べなくていいので、内側のループを抜ける（高速化）
            }
        }
        
        if (canPass){
            canRoad.push(i + 1);
        }
    }

    // 出力（elseでしっかり分岐させる）
    if (canRoad.length === 0){
        console.log("wait");
    } else {
        console.log(canRoad.join(" "));
    }
});
```


```js
let canRoad = [];
    for (let i = 0; i < N; i++){
        // roadsの「全ての行(row)」において、i列目がM未満であるかチェック
        if (roads.every(row => row[i] < M)) {
            canRoad.push(i + 1);
        }
    }
```
