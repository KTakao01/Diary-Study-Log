# paizaB
## 問題
https://paiza.jp/challenges/572
### 自身の回答（正解）
```js
process.stdin.resume();
process.stdin.setEncoding('utf8');
// 自分の得意な言語で
// Let's チャレンジ！！
var lines = [];
var reader = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});
reader.on('line', (line) => {
  lines.push(line);
});
reader.on('close', () => {
  let currentLine = 0;
  const N = Number(lines[currentLine++]);
  // 教習車の配列作成
  let cars = [];
  for(let i = 0;i<N; i++){
      cars.push(Number(lines[currentLine++]));
  }
  // 教習車がいなくなるまでループで順番に出口から出て行く車を判定する
  let currentNo = 1;
  let ans = 0;
  let tmp = 0;
  while(currentNo != N){
    //   console.log(cars)
      tmp = cars[0];
      cars.shift();
      if (currentNo != tmp){
          cars.push(tmp);
          if (tmp == N){
              ans++;
          }
      } else {
          currentNo++;
      }
  }
  console.log(ans);
});

// 入力例1
// 5
// 5
// 2
// 1
// 3
// 4

// currentNo = 1++ Nまで
// [5,2,1,3,4] // tmp = arr[0]
// if currentNo != [0] // [2,1,3,4,] arr[arr.length-1]=5 もしくは arr.push(tmp) // [2,1,3,4,5] 
//....ループ // whileかな //　配列要素無くなるまで
// if currentNo == [0] // [1,3,4,5,2] // arr.shift()
```

### 改善例
```js
// 結論から言うと、見た目は1重ループですが、中身の処理を含めると $O(N^2)$ になります。その理由は、cars.shift() の計算コスト（処理の重さ） にあります。なぜ shift() が重いのか？配列（Array）の先頭から要素を削除する shift() は、単に「ポン」と取り出すだけではありません。先頭の要素を消す。残ったすべての要素を、1つずつ前にずらす（インデックスを詰め直す）。という作業を裏で行っています。つまり、配列に $N$ 個の要素があるとき、shift() 1回にかかるコストは $O(N)$ です。コード上では1行に見えますが、計算機の中では「残りの全員を一歩前に歩かせる」というループ処理（隠れたループ）が走っていると考えてください。
```

```js
// なぜこれで解けるのか（入力例1でのトレース）入力: 5, 2, 1, 3, 4 （N=5）ステップ 1: 位置情報の記録配列を走査せず、辞書（ここでは配列 pos）を作ります。1番の車は インデックス 22番の車は インデックス 13番の車は インデックス 34番の車は インデックス 45番の車は インデックス 0ステップ 2: 順番に比較$1 \to 2$:位置 2 $\to$ 位置 1 （数字が減った！＝戻るには1周必要）周回数: 1$2 \to 3$:位置 1 $\to$ 位置 3 （増えた＝そのまま進める）周回数: 1$3 \to 4$:位置 3 $\to$ 位置 4 （増えた＝そのまま進める）周回数: 1$4 \to 5$:位置 4 $\to$ 位置 0 （減った！＝戻るには1周必要）周回数: 2結果: 2 （正解）
```

```js
process.stdin.resume();
process.stdin.setEncoding('utf8');

var lines = [];
var reader = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});

reader.on('line', (line) => {
  lines.push(line);
});

reader.on('close', () => {
  // 1行目はN
  const N = Number(lines[0]);
  
  // 【改善点1】 各車番が「配列の何番目にあるか」を記録するマップ（配列）を作る
  // pos[車番] = その車番の初期位置(インデックス)
  const pos = new Int32Array(N + 1); 
  
  for (let i = 0; i < N; i++) {
    const carNum = Number(lines[i + 1]);
    pos[carNum] = i;
  }

  // 【改善点2】 1からNまで順番に見ていき、位置が戻る回数を数える
  let laps = 0;
  
  // 1番の車からスタートし、2, 3...と順に位置を確認する
  for (let target = 1; target < N; target++) {
    const currentPos = pos[target];
    const nextPos = pos[target + 1];

    // 次の車(target+1)が、今の車(target)より手前(インデックスが小さい)にある場合、
    // それを見つけるためにコースを1周(ラップ)する必要があるということ
    if (nextPos < currentPos) {
      laps++;
    }
  }

  console.log(laps);
});
```