# paiza B
https://paiza.jp/challenges/904/

## 自身の回答（正解）

```js
process.stdin.resume();
process.stdin.setEncoding('utf8');
// 自分の得意な言語で
// Let's チャレンジ！！
var lines = [];
var reader = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});
reader.on('line', (line) => {
  lines.push(line);
});
reader.on('close', () => {
//   console.log(lines[0]);
 let currentLine = 0;
 const [N,M] = lines[currentLine++].trim().split(" ").map(Number);
 const K = Number(lines[currentLine++]);
 let map = Array.from({length:N+1},()=>Array(M+1).fill(0));
//  console.log(map)
 for(let i=0;i < K; i++){
     let [r,c] = lines[currentLine++].trim().split(" ").map(Number);
     for (let row = -1; row <= 1; row++){
         for (let col = -1; col <=1; col++){
             let [x,y] = [r+row,c+col];
             if (1<=x && x <= N && 1 <= y && y<= M){
                map[x][y] = 1;
             }
         }
     }
 }
 const mapOnth = map.flat([1]);
  console.log(mapOnth.filter(data => data == 1).length)
 

});

// N M
// K
// R_1 C_1
// R_2 C_2
// ...
// R_K C_K

// 入力例1
// 5 5
// 2
// 2 2
// 3 4
// 出力例1
// 16

// rc. 
//r-1 c-1 ~ r-1 c+1
//r c-1 ~ r c+1
//r+1 c-1 ~ r c+1
// スプリンクラーの周辺が枠外にはみ出す場合あり
```

## 改善
```markdown
改善できる3つのポイント
flat() と filter() のオーバーヘッド削減
現在のコードの map.flat([1]).filter(...) は、新しく配列を2回も生成するため、メモリ消費と処理時間が増加します。
【改善策】 散水フラグを 1 に書き換える瞬間に、カウンター変数（wateredCount など）を +1 するだけで、最後に集計する手間とメモリを完全に省けます。

ループ内の分割代入（配列生成）の省略
let [x, y] = [r + row, c + col]; は直感的で美しいですが、ループが回るたびに不要な配列オブジェクトが生成・破棄（ガベージコレクション）されるため、塵も積もれば速度低下に繋がります。
【改善策】 単純な変数代入 let x = r + row; に変更します。

標準入力の受け取り方の高速化
readline を使った非同期処理よりも、fs.readFileSync を使って一括で同期的に読み込む方が、コードが短くなり実行速度も上がります。
```


```js
// 自分の得意な言語で
// Let's チャレンジ！！
const fs = require('fs');

function main() {
  // 入力を一括で読み込み、空白と改行で分割
  const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split(/\s+/);
  if (input.length === 0 || input[0] === "") return;

  let pointer = 0;
  const N = Number(input[pointer++]);
  const M = Number(input[pointer++]);
  const K = Number(input[pointer++]);

  // N+1 x M+1 の2次元配列を作成
  let map = Array.from({ length: N + 1 }, () => Array(M + 1).fill(0));
  
  // 水が撒かれた区画の数をカウントする変数
  let wateredCount = 0;

  for (let i = 0; i < K; i++) {
    const r = Number(input[pointer++]);
    const c = Number(input[pointer++]);

    // スプリンクラーとその周囲8マスをチェック
    for (let row = -1; row <= 1; row++) {
      for (let col = -1; col <= 1; col++) {
        const x = r + row;
        const y = c + col;

        // 庭園の範囲内かチェック
        if (1 <= x && x <= N && 1 <= y && y <= M) {
          // まだ水が撒かれていない区画なら、1にしてカウントアップ
          if (map[x][y] === 0) {
            map[x][y] = 1;
            wateredCount++;
          }
        }
      }
    }
  }

  // 結果を出力
  console.log(wateredCount);
}

main();

```