# paiza B
## 射撃訓練
https://paiza.jp/challenges/812

### 自身の回答（正解）
``` js
process.stdin.resume();
process.stdin.setEncoding('utf8');
// 自分の得意な言語で
// Let's チャレンジ！！
var lines = [];
var reader = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});
reader.on('line', (line) => {
  lines.push(line);
});
reader.on('close', () => {
  let current = 0;
  const [H,W] = lines[current++].trim().split(" ").map(Number);
  const N = Number(lines[current++].trim());
  let point = Array.from({length:H+1},()=>Array(W+1).fill(0));
//   console.log(point)
  
  // 配列のインデックスを座標に見立てて、ポイントを要素として格納する
  // N行のポイント情報取得
  for(let i = 0; i < N; i++){
      let [r,c,p,q] = lines[current++].trim().split(" ").map(Number);
    //   console.log(r,c,p,q)
    // console.log(r-1,c-1,p,q)
    //   console.log(r,c-1,p,q)
    //   console.log(r+1,c-1,p,q)
    // console.log(point[r-1][c-1])
    // console.log(point[r][c-1])
    // console.log(point[r+1][c-1])

      // 上中下行の的の左から右端までポイントを要素として格納する
      for(let col = 0; col <= 2; col++ ){
          // 玉が枠の外だった場合、計算しない
          if ((r-1 <= H) && (c-1+col <= W) ){
              point[r-1][c-1+col] = q;
          }
          if ((r <= H) && (c-1+col <= W) ){
              point[r][c-1+col] = q;
          }
          if ((r+1 <= H) && (c-1+col <= W) ){
              point[r+1][c-1+col] = q;
          }
          
        //   console.log(current);
          if (c-1+col == c){
              point[r][c-1+col] = p;
          }
        //   console.log(point)
      }
  }
        // console.log(point)
    const M = Number(lines[current++].trim());
    let ans = 0;
    // 実際に当たった座標
    for(let i = 0; i < M; i++){
        let [a,b] = lines[current++].trim().split(" ").map(Number);
        if (a <= H && b <= W){
            ans += point[a][b];
        }
    }
    console.log(ans);
  
  
});
// H W
// N
// r_1 c_1 p_1 q_1
// r_2 c_2 p_2 q_2
// ...
// r_N c_N p_N q_N
// M
// a_1 b_1
// a_2 b_2
// ...
// a_M b_M
// 10 10
// 5
// 2 2 4 2
// 3 9 3 1
// 5 5 6 3
// 8 3 4 1
// 9 7 3 1
// 5
// 5 5
// 2 8
// 7 7
// 3 3
// 8 3

//　的の領域の座標の法則
// 緑色の中心の的r,cとすると左端はr-1,c-1/r,c-1/r+1,c-1
// 上、中、下行
// { [r,c] : point }//無理
// 配列のインデックス→座標に見立てる

//[[],[]] H+1個の要素、要素配列の要素W+1個 //インデックス0,0は0にする
//
```

### 改善後
```js
process.stdin.resume();
process.stdin.setEncoding('utf8');

var lines = [];
var reader = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});

reader.on('line', (line) => {
  lines.push(line);
});

reader.on('close', () => {
  let current = 0;
  
  // 1. 入力のパース
  const [H, W] = lines[current++].trim().split(" ").map(Number);
  const N = Number(lines[current++].trim());
  
  // 2. 盤面の作成（0埋め）
  // TypedArray (Int32Array) を使うとメモリ効率が良いですが、通常の Array でもOK
  const grid = Array.from({ length: H + 1 }, () => new Array(W + 1).fill(0));

  // 3. 的の情報を書き込む
  for (let i = 0; i < N; i++) {
    const [r, c, p, q] = lines[current++].trim().split(" ").map(Number);

    // ★改善ポイント: 上下左右(3x3)を2重ループで回す
    // y は 行 (r-1 〜 r+1), x は 列 (c-1 〜 c+1)
    for (let y = r - 1; y <= r + 1; y++) {
      for (let x = c - 1; x <= c + 1; x++) {
        
        // ★改善ポイント: 枠内チェックを1箇所にまとめる
        // 1以上 H以下、かつ 1以上 W以下
        if (y >= 1 && y <= H && x >= 1 && x <= W) {
          
          // 中心(r,c)なら p、それ以外なら q
          if (y === r && x === c) {
            grid[y][x] = p;
          } else {
            grid[y][x] = q;
          }
        }
      }
    }
  }

  // 4. 射撃結果の集計
  const M = Number(lines[current++].trim());
  let totalScore = 0;

  for (let i = 0; i < M; i++) {
    const [a, b] = lines[current++].trim().split(" ").map(Number);
    
    // 入力条件で 1 <= a <= H は保証されていますが、安全のためチェックしても良い
    // 配列の範囲内であれば加算
    if (grid[a] && grid[a][b] !== undefined) {
      totalScore += grid[a][b];
    }
  }

  console.log(totalScore);
});
```