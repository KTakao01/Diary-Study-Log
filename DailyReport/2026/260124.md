# paiza
Bランク獲得ストーリーなど
配列活用メニュー
https://paiza.jp/works/mondai/array_utilization_primer/problem_index?language_uid=javascript
##　ミスの原因
・JavaScriptのオブジェクトは、初期値がないキーにアクセスすると undefined になる。　　
undefined + 1 を計算すると、答えは数字ではなく NaN (Not a Number) になります。

❌
``` js
let obj = {};
obj["apple"] += 1; 
console.log(obj); // 結果: { "apple": NaN }  ← カウントできてない！
```

⭕️
```
// 値が存在すればその値、なければ 0 を使って +1 する
as_arr[key] = (as_arr[key] || 0) + 1;
```

・連想配列のObject.keys(obj)は計算量がかかる。
一度、キーだけを取り出した新しい配列をメモリ上に作成


・「初期値をエラー値（-1）にしておく」というのは、探索アルゴリズムの鉄板テクニック

・Math.max(...ar)として配列展開すべきところMath.max(ar)としてた。Math.max(...ar)とすべきところMath.max()としていた

・[「長テーブルのうなぎ屋 (力試し編) JavaScript編」](https://paiza.jp/works/mondai/b_rank_skillcheck_sample/long-table_01/edit?language_uid=javascript)

// 円卓に対応、最大番号→最小番号に対応するように
    let sur_j = j % seat_sum;

```js
      for (let j = seat_first - 1; j < (seat_first - 1) + arr_len ; j++){
    // 円卓に対応、最大番号→最小番号に対応するように
    let sur_j = j % seat_sum;
    // console.log("sur_j",sur_j,seat_ar[sur_j])
    if (seat_ar[sur_j] == true ) {
        can_seat = false;
        break
    } else {
        can_seat = true
    }
  }
// console.log("can_seat",can_seat)
  // ループ終了後、can_seat=trueなら実際に座席をtrueにする
  if (can_seat) {
  for (let i = seat_first - 1 ; i < (seat_first - 1) + arr_len; i++ ) {
      let sur_i = 0; // 最大席数を超える番号
    if(i > seat_sum) {
        sur_i = i % seat_sum
    } else {
        sur_i = i
    } 
    seat_ar[sur_i] = true
  }
}
// console.log(seat_ar)
 
```