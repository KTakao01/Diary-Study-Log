# done
recursion 上級　木構造コーディング問題演習</br>
# report
https://recursionist.io/dashboard/course/3/lesson/463</br>

### iterator.rightとiterator.right.valueのnilについて
>コードの出力

iterator.right &{<nil> <nil> <nil>}
から、iterator.rightはnilでないことがわかります。iterator.rightはBinaryTree構造体のポインタを指していますが、この構造体インスタンスのdataフィールドはnilで、その他のフィールド（leftとright）もnilです。

Goでは、ポインタのデフォルト値はnilですが、ポインタが非nil値を指している場合、ポインタの指しているインスタンスのフィールドがnilである可能性があります。例として、以下のような場合を考えてみましょう。

```
type BinaryTree struct {
    data  *Integer
    left  *BinaryTree
    right *BinaryTree
}

type Integer struct {
    value int32
}

func main() {
    b := &BinaryTree{
        data: nil,
        left: nil,
        right: nil,
    }
    fmt.Println(b) // 出力: &{<nil> <nil> <nil>}
}
```
bはnilでないBinaryTreeへのポインタですが、data、left、rightフィールドはすべてnilです。

これは、iterator.rightがnilでなく、それが指す構造体のフィールドがnilであるため、ループ条件iterator.right != nilがtrueと評価され、ループが実行される原因です。

解決策としては、構造体のフィールドが有効な値を持っているかをチェックし、それに基づいてロジックを組むか、コードの他の部分を調査して、なぜこのような状態（dataがnilのノード）が発生しているのかを理解することです。もしこれが意図的でない場合、その原因を特定して修正することをお勧めします。

### 根ルードの値を何にするかについて
https://recursionist.io/dashboard/course/3/lesson/464

>質問</br>
バランス保持: 中央の値を根として選択することで、左右の部分木が均等なサイズになります（または、可能な限り均等）。これにより、ツリーはバランスを保つことができ、操作の効率が最大化されます。</br>
とありますが、例えば[1,2,3,4]と[1,2,3,4,5]と配列のサイズが偶数か奇数かによって中央がかわるんでは？</br>特に偶数の場合、ここでは2が選択されていますが、3を選択してもOKでは？</br>

>ChatGPT</br>
おっしゃるとおりで、配列が [1,2,3,4]（偶数の要素数）と [1,2,3,4,5]（奇数の要素数）では中央値が異なり、特に偶数要素数の配列では真ん中のどちらを選んでも良いとされています。つまり、[1,2,3,4]の場合には2あるいは3を選んでもバリッドです。</br>

mid := (start + end) / 2 の計算では、要素数が偶数の場合、2つの中央値のうち小さい方が選ばれます。つまり、[1,2,3,4]では2が選ばれます。一方で、計算を mid := (start + end + 1) / 2 のようにすれば、大きい方の値が選ばれます。</br>

どちらの値を選んでも、基本的にはバランスがとれたツリーが構築できるため、どちらを選んでも問題ありません。ただ、選ぶ値によって構築されるツリーの形状は異なることになります。</br>

一般に、どちらの中央値を選んでも、バランス木の条件（すなわち、左右のサブツリーの高さが1以上異ならない）を満たすことはできますが、アルゴリズムや実装によっては、一方を好むケースもあります。具体的な好みはアプリケーションやその他の要因によりますので、どちらを選ぶかは開発者の裁量になります。</br>


