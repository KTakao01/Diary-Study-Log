# done
recursion 上級　木構造コーディング問題演習</br>
# report
https://recursionist.io/dashboard/course/3/lesson/463</br>

### iterator.rightとiterator.right.valueのnilについて
>コードの出力

iterator.right &{<nil> <nil> <nil>}
から、iterator.rightはnilでないことがわかります。iterator.rightはBinaryTree構造体のポインタを指していますが、この構造体インスタンスのdataフィールドはnilで、その他のフィールド（leftとright）もnilです。

Goでは、ポインタのデフォルト値はnilですが、ポインタが非nil値を指している場合、ポインタの指しているインスタンスのフィールドがnilである可能性があります。例として、以下のような場合を考えてみましょう。

```
type BinaryTree struct {
    data  *Integer
    left  *BinaryTree
    right *BinaryTree
}

type Integer struct {
    value int32
}

func main() {
    b := &BinaryTree{
        data: nil,
        left: nil,
        right: nil,
    }
    fmt.Println(b) // 出力: &{<nil> <nil> <nil>}
}
```
bはnilでないBinaryTreeへのポインタですが、data、left、rightフィールドはすべてnilです。

これは、iterator.rightがnilでなく、それが指す構造体のフィールドがnilであるため、ループ条件iterator.right != nilがtrueと評価され、ループが実行される原因です。

解決策としては、構造体のフィールドが有効な値を持っているかをチェックし、それに基づいてロジックを組むか、コードの他の部分を調査して、なぜこのような状態（dataがnilのノード）が発生しているのかを理解することです。もしこれが意図的でない場合、その原因を特定して修正することをお勧めします。

### 根ルードの値を何にするかについて
https://recursionist.io/dashboard/course/3/lesson/464

```
質問</br>
バランス保持: 中央の値を根として選択することで、左右の部分木が均等なサイズになります（または、可能な限り均等）。これにより、ツリーはバランスを保つことができ、操作の効率が最大化されます。</br>
とありますが、例えば[1,2,3,4]と[1,2,3,4,5]と配列のサイズが偶数か奇数かによって中央がかわるんでは？</br>特に偶数の場合、ここでは2が選択されていますが、3を選択してもOKでは？</br>
```

```
ChatGPT</br>
おっしゃるとおりで、配列が [1,2,3,4]（偶数の要素数）と [1,2,3,4,5]（奇数の要素数）では中央値が異なり、特に偶数要素数の配列では真ん中のどちらを選んでも良いとされています。つまり、[1,2,3,4]の場合には2あるいは3を選んでもバリッドです。
mid := (start + end) / 2 の計算では、要素数が偶数の場合、2つの中央値のうち小さい方が選ばれます。つまり、[1,2,3,4]では2が選ばれます。一方で、計算を mid := (start + end + 1) / 2 のようにすれば、大きい方の値が選ばれます。
どちらの値を選んでも、基本的にはバランスがとれたツリーが構築できるため、どちらを選んでも問題ありません。ただ、選ぶ値によって構築されるツリーの形状は異なることになります。
一般に、どちらの中央値を選んでも、バランス木の条件（すなわち、左右のサブツリーの高さが1以上異ならない）を満たすことはできますが、アルゴリズムや実装によっては、一方を好むケースもあります。具体的な好みはアプリケーションやその他の要因によりますので、どちらを選ぶかは開発者の裁量になります。
```

### 分割統治法について
https://recursionist.io/dashboard/course/3/lesson/464</br>

```
不等式に＝をつけないと正しい結果が得られないのはなぜ
	ChatGPT
注目されている不等号に関連して、考察をします。
```

```
以下が2つのバージョンの異なる部分です：

1. バージョン1:
2. バージョン2:

このコードが生成するBST（Binary Search Tree）を作るロジックは、与えられたソートされた配列を半分に分割して中央の要素を根としてノードを作り、残りの2つの部分を再帰的に同じ手続きを適用することです。

ここで気を付けるべきは、midに対する不等号の取り扱いです。不等号に等号（<=、>=）を含めるか含めないか（<、>）で、サイズが2や3の小さい配列を処理する際の挙動が変わります。

- サイズが2の場合、例えば [1, 2] が入力であったとき、mid は 0 となります。2つ目のバージョン（<、>を使用するもの）では、mid+1 は 1 で end も 1 なので、右部分木の作成はスキップされ、結果は [2] となります。1つ目のバージョンでは、mid+1 は end と等しいので、右部分木が作成され、結果は [2, null, 1] となります。
- サイズが3の場合、例えば [1, 2, 3] が入力であったとき、mid は 1 となります。2つ目のバージョンでは、start が 0 で mid-1 も 0 なので、左部分木の作成はスキップされ、結果は [2, 1, 3] となります。この出力はテストケースの期待結果と一致します。

左部分木や右部分木を作成する条件を変えることで、BSTの形が変わり、その結果としてテストケースがパスするかどうかが変わります。どちらのバージョンが正しいかは、テストケースや問題文の要件に依存します。上記の例から、おそらく等号を含めた方が期待される挙動をするのではないかと推測されます。
```

## 二分木の構築の際の再帰のプロセス
https://recursionist.io/dashboard/course/3/lesson/456

左部分木処理したあと右部分木処理。ある程度同時並行だけどスタックの都合で、右部分木と左部分木が完全には１体１で並列的に作成されない。</br>左部分木の左部分木というように左部分木をつきつめてベースケースリターンのあとわたされた左部分木の右部分木の処理を行い、その中で必要があればその右部分木の探索を行いその右部分木のベースケースでリターンがかえってきて、その右部分木処理が簡潔する。</br>
最終的に右部分木にも同様のプロセス。</br>