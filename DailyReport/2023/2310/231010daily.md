# done
recursion 上級　木構造コーディング問題演習
# report

配列からどんな木構造をつくられるかは配列と、再帰のアルゴリズムにより違う。</br>

再帰のアルゴリズム</br>
https://recursionist.io/dashboard/course/3/lesson/467
・中央値を根ノードとする</br>
ソート配列を元に二分探索木を作ってるので、</br>
(距離が近いほど、ノードの値は近くなるとは限らない？配列要素にもよるし、ただし配列要素が1ずつ増かしているときの右ノードだけを見ると別。法則としては汎用性ない)</br>

https://recursionist.io/dashboard/course/3/lesson/466
・ランダムにシャッフルした配列を一つずつ木構造として構築していく。</br>
insert関数は挿入のたびにiterator=rootに設定して、探索して適切な位置を見つける</br>

このアプローチでは距離が近いほど、ノードの値は近くなるとは限らない</br>


### DB設計
第一正規形:列の値、1つ</br>
第二正規形:部分関数従属の解消</br>
第三正規形:推移的関数従属の解消</br>

### 再帰のプロセス
https://recursionist.io/dashboard/course/3/lesson/467
探索のみの再帰は上から順に確定。（ベースケールで下から戻るが処理する必要がない。）</br>

木構造構築の再帰は上から順に探索して左と右部分木を見つけられる下から確定。</br>

### 再帰プロセス内の変数、戻り値
https://recursionist.io/dashboard/problems/submissions/678833
```
Goのスライスは参照型ではありますが、関数にスライスを渡した場合、そのスライスのコピーが関数に渡されます。したがって、関数内でスライスに要素を追加すると、新しいスライスが作成され、その新しいスライスに要素が追加されます。このため、元のスライスには影響がありません。

このコードは、preorderWalk関数内でresultsスライスに要素を追加していますが、この変更はpreorderWalk関数の外では反映されません。したがって、preorderTraversal関数で返されるresultsスライスは空のままです。

解決策として、resultsスライスをポインタで渡すか、resultsスライスを更新するための新しいスライスを返すことができます。
```

### 木構造の計算量（走査と探索）
```
maximumDepthの意図は最悪な場合、特定の要素を探索するにはlog nのステップが必要です(例え最大値の探索)。それによって木の高さや最長のパス(最長の深さ)もlog nです。nとlog nではlog nが遥かに早い、(n^2)と(n log n)もn log nが遥かに早いです。走査でしたらn、探索はlog n。256要素あるのに、探索にはlog 256に近いステップだけが必要です。 
```
```
ありがとうございます。
・走査の定義を勘違いしてました。再帰的に探索しているのでノードと隣接していないノードでも１回のプロセスで処理を終えているのに、隣接ノードをたどっていくと誤解していました。走査がnの理由がわかりました。
・パスは同じノードを繰り返し通ると勘違いしていたので最長のパスが木の高さと同じlognというのも理解しました。
```

### 木構造の走査
https://recursionist.io/dashboard/course/3/lesson/466
走査：根ノードの調査と左/右部分木の探索
前順：NLR
後順:LRN  (覚え方→前順を一つずらす。(N)LRNLR)

### 再帰のベースケース
https://recursionist.io/dashboard/course/3/lesson/471
JavaScript
動的配列: JavaScriptの配列は動的です。要素を追加すると、配列は自動的にリサイズします。新しい要素を追加したり削除したりしても、配列オブジェクト自体は変更されず、その内容のみが変更されます。

関数とオブジェクト: JavaScriptではオブジェクトや配列を関数に渡すと、その参照が渡されます。したがって、関数内でオブジェクトや配列を変更すると、その変更は関数の外部でも反映されます。

Java
動的配列: JavaにおけるArrayListなどのコレクションクラスは、内部の配列サイズを動的に変更して要素を管理します。ArrayListに要素を追加すると、必要に応じて内部配列のサイズが増加しますが、これは新しい配列を作成し、既存の要素を新しい配列にコピーすることで実現されます。元の配列自体が動的にリサイズされるわけではありません。

関数とオブジェクト: Javaでは、オブジェクトはその参照を通して渡されます。したがって、関数内でオブジェクトのフィールドを変更すると、それは関数の外部でも反映されます。しかし、新しいオブジェクトを作成し、それを既存の変数に代入すると、それは外部のオブジェクトには影響しません。
Go: スライスは内部の配列への参照を含む値（＝ポインタ、長さ、容量）がコピーされて関数に渡されるため、スライス自体を変更する（例えば、新しいメモリを割り当てる）と、それが関数外に反映されるわけではありません。したがって、新しいスライスを作成して戻り値として返し、呼び出し元でその結果を使用する必要があります。

Go
例）results = append(results, root.data.value)  // (3)
容量を超えると新しい配列が作成され、既存の配列要素が新しい配列にコピーされる。そして新しいスライスが作成される。スライスは配列要素の参照渡しで値を扱っている。

関数に渡すときはGoではスライスの値が（＝ポインタ、長さ、容量）がコピーされて渡される。しかしポインタコンポーネント（スライスは配列の参照）は同じ配列を示すため関数内でのスライスの要素を変更してもその変更は関数の外でも反映される。

例外として関数ないでスライス自体を変更すると、関数外部のスライスには反映されない。戻り値として返し、呼び出し元で受け取らない限り、関数内部で完結する。

```go
package main

import "fmt"

func modifySlice(s []int) {
    s[0] = 100  // これは呼び出し元のスライスに影響します
    s = append(s, 4)  // これは呼び出し元のスライスに影響しません
}

func main() {
    a := []int{1, 2, 3}
    modifySlice(a)
    fmt.Println(a)  // [100 2 3] を出力します
}

```

### 再帰の戻り値について
https://recursionist.io/dashboard/problems/submissions/679036

```
    A
   / \
  B   C
 /     \
D       E


はい、その解説は基本的に正確です！順を追って確認しましょう。

左部分木の探索を葉ノードまで行う

具体的には、現在のノード（仮にノードAとします）から始めて、その左部分木を再帰的に探索します。そのため、左部分木の各ノードでも同様にそのノードの左部分木が探索され、これが葉ノードに到達するまで続きます。
葉ノードのスライスへの追加

葉ノード（左部分木も右部分木も持たないノード）に到達したら、そのノードの値がresultsスライスに追加されます。
追加後のスライスが探索結果としてreturnされ、上位の左部分木の処理に移る

葉ノードの値を追加したresultsスライスは、そのノードに対する関数呼び出しの結果として返されます。そして、そのノードの親ノード（仮にノードBとします）における処理が再開されます。
今のノードのスライスへの追加

ノードBでは、左部分木の探索が終わって結果がresultsスライスに追加された後、ノードB自体の値がresultsスライスに追加されます。
追加後のスライスが結果としてreturnされ上位の左部分木の処理に移る

ノードBの値を追加したresultsスライスは、ノードBに対する関数呼び出しの結果として返され、ノードAにおける処理が再開されます。
根ノードの右部分木に対して同様の処理が行われる

ノードA（根ノード）では、左部分木の探索が終わって結果がresultsスライスに追加された後、右部分木に対して同様の処理（右部分木の左部分木の探索、右部分木の右部分木の探索、右部分木のノード値の追加）が行われます。
最後に根ノード自体の値がresultsスライスに追加され追加後のスライスが根ノードに対する関数呼び出しの結果として返される

最後に、全ての部分木の探索が終わり、それらの結果がresultsスライスに追加された後、根ノードA自体の値がresultsスライスに追加され、このresultsスライスが最終結果として返されます。
上記の説明が正確で、理解している通り、各ノードで行われる処理はそのノードの左部分木と右部分木に対する再帰的な探索、そしてそのノード自体の値の追加、となります。そして、この処理が根ノードから始まり、全てのノードで再帰的に行われることで、全ツリーに対するポストオーダー探索が実現されます。
```

内部処理はログで出力できないので模式的に理解するしかない。
プログラムは上から順に処理されること→プロセスがわかる
ベースケースがあること→プロセスの終わりがわかる
returnがあること→上の階層の変数にマージされることがわかる
処理前のresults→return results(処理後のresultsを返す)→返ってきたresultsをresultsとして更新する。


```
再帰のようにベースケースで初めて戻り値を返してくるような処理でも戻り値を返さない探索の段階で再代入することが可能なことから再帰のプロセスの前に、関数のシグネチャを評価するプロセスがあると思われる
ChatGPT
関数のシグネチャを評価するというのは、関数が呼び出される際に引数の型、戻り値の型、そして関数本体のスコープなどがコンパイラによって確認されるプロセスです。Go言語では、コンパイル時に静的型チェックが行われ、関数呼び出しの引数や戻り値がシグネチャと一致しているかどうかをチェックします。

再帰関数のプロセスにおいては、関数が実行される際に、その関数本体内での各ステートメントが順に評価・実行されていきます。再帰関数も通常の関数と同じく、関数が呼び出されるとその実行コンテキスト（ローカル変数、引数、など）がスタックメモリ上にプッシュされ、関数の実行が終了すればそのコンテキストはポップされます。
```