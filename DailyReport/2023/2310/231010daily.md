# done
recursion 上級　木構造コーディング問題演習
# report

配列からどんな木構造をつくられるかは配列と、再帰のアルゴリズムにより違う。</br>

再帰のアルゴリズム</br>
https://recursionist.io/dashboard/course/3/lesson/467
・中央値を根ノードとする</br>
ソート配列を元に二分探索木を作ってるので、</br>
(距離が近いほど、ノードの値は近くなるとは限らない？配列要素にもよるし、ただし配列要素が1ずつ増かしているときの右ノードだけを見ると別。法則としては汎用性ない)</br>

https://recursionist.io/dashboard/course/3/lesson/466
・ランダムにシャッフルした配列を一つずつ木構造として構築していく。</br>
insert関数は挿入のたびにiterator=rootに設定して、探索して適切な位置を見つける</br>

このアプローチでは距離が近いほど、ノードの値は近くなるとは限らない</br>


### DB設計
第一正規形:列の値、1つ</br>
第二正規形:部分関数従属の解消</br>
第三正規形:推移的関数従属の解消</br>

### 再帰のプロセス
https://recursionist.io/dashboard/course/3/lesson/467
探索のみの再帰は上から順に確定。（ベースケールで下から戻るが処理する必要がない。）</br>

木構造構築の再帰は上から順に探索して左と右部分木を見つけられる下から確定。</br>

### 再帰プロセス内の変数、戻り値
https://recursionist.io/dashboard/problems/submissions/678833
```
Goのスライスは参照型ではありますが、関数にスライスを渡した場合、そのスライスのコピーが関数に渡されます。したがって、関数内でスライスに要素を追加すると、新しいスライスが作成され、その新しいスライスに要素が追加されます。このため、元のスライスには影響がありません。

このコードは、preorderWalk関数内でresultsスライスに要素を追加していますが、この変更はpreorderWalk関数の外では反映されません。したがって、preorderTraversal関数で返されるresultsスライスは空のままです。

解決策として、resultsスライスをポインタで渡すか、resultsスライスを更新するための新しいスライスを返すことができます。
```