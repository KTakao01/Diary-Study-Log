# done
recursion 上級　木構造 時間</br>
面談など企業研究 1.5時間</br>
# report
https://recursionist.io/dashboard/course/3/lesson/462</br>
反省点</br>
再帰はそれぞれのスタックコールで異なる関数のスコープをもってるので内部で定義するとだめ。</br>
引数に渡すことで異なるスコープ間でも保持できる</br>

難しかった点</br>
・再帰関数で結果を保持するために作ったスライスをポインタにする</br>
・木構造の探索プロセスを再帰的に求める時の再帰の順序を考える</br>
・左探索→値チェック→右探索の順に再帰関数を構成すると昇順になる</br>


& アドレスオペレータを用いて変数のアドレスを取得。ポインタ変数に保存できる</br>
```
results := []*Integer{}
bigger(root, key, &results)
```

* でリファレンスオペレータを用いてアドレスの指す値を取得</br>
```
func bigger(root *BinaryTree, key int32, results *[]*Integer) {
	// ...
	*results = append(*results, someNewInteger)
	// ...
}
```

・関数が最後まで実行されると自動的にその関数から呼び出し元へ制御が戻る</br>

ポインタにするタイミングについて</br>

>なので、以下のコードフラグメントの場合：

go
Copy code
func bigger(root *BinaryTree, key int32, results *[]*Integer) {
    //...
    bigger(root.left, key, results)
    //...
}
resultsはすでにポインタとして渡されているので、再帰呼び出しにresultsをそのまま渡しても、resultsが指すスライスの実体は同じものを指し続けます。

逆に、もしアドレスオペレータ&を使用した場合：

go
Copy code
func bigger(root *BinaryTree, key int32, results *[]*Integer) {
    //...
    bigger(root.left, key, &results)
    //...
}
これはコンパイルエラーになります。なぜなら、&resultsは**[]*Integer（ポインタのポインタ）を表し、関数biggerは*[]*Integerを期待しているからです。なので、&を使用する必要はありません。

基本的に、Go言語においてスライスやマップを関数に渡す場合、そのデータを変更する意図があるのであればポインタを使用することがあります。一方で、配列、構造体、整数、浮動小数点数などを関数に渡す場合、そのデータを変更する意図があるならばポインタを使用します。そしてポインタが渡された場合、再帰などの中でそのポインタをそのまま渡すことで、同じメモリアドレスを指すことになります。

再帰のプロセスについて</br>
>はい、その通りです。以下のベースケースにより、再帰の終了点（最後の関数）を確認することができます。

go
Copy code
if root == nil || root.data == nil {
    fmt.Println("a", root)
    return
}
ここでのreturnステートメントは、rootがnilまたはroot.dataがnilの場合に、これ以上の処理（子ノードへの再帰呼び出しやデータの追加）を行わず、直ちに関数から抜け出すことを意味します。これはベースケースとなり、再帰の一連の呼び出しが「最後」であることを示すものと言えます。

このベースケースがないと、nilノードにアクセスしてしまい、ランタイムエラーが発生します。再帰呼び出しの際には特に、このようなベースケースを適切に設定し、エラーを防ぐことが重要となります。

上記のfmt.Println("a", root)はデバッグ用の出力で、returnが実行されたタイミングでどのrootがnilであったかをログとして残す役割を果たします。これを用いることで、関数の動きやベースケースがどのような状況で呼び出されるかを確認することができます。

・二分探索木</br>
階層の高さに比例するのは右か左かどちらか方方向にのみ探索したときだけ。途中、異なる方向（右→左→右）に探索すると階層の高さとノードの値の大小関係は単純に比例しない。</br>
そのため最大、最小は取得しやすい。</br>

別解）場合分けして解く</br>
https://recursionist.io/dashboard/problems/submissions/368536
条件に合うのを一旦保存。最小を求めるために条件を厳しくする。その結果、条件に合わなくても前の条件で保存したsuccessorがある。</br>