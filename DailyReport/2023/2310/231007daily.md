# done
recursion 上級　木構造 時間</br>
面談など企業研究 1.5時間</br>
# report
https://recursionist.io/dashboard/course/3/lesson/462</br>

難しかった点</br>
・再帰関数で結果を保持するために作ったスライスをポインタにする</br>
・木構造の探索プロセスを再帰的に求める時の再帰の順序を考える</br>



& アドレスオペレータを用いて変数のアドレスを取得。ポインタ変数に保存できる</br>
```
results := []*Integer{}
bigger(root, key, &results)
```

* でリファレンスオペレータを用いてアドレスの指す値を取得</br>
```
func bigger(root *BinaryTree, key int32, results *[]*Integer) {
	// ...
	*results = append(*results, someNewInteger)
	// ...
}
```

・関数が最後まで実行されると自動的にその関数から呼び出し元へ制御が戻る</br>

ポインタにするタイミングについて</br>

>なので、以下のコードフラグメントの場合：

go
Copy code
func bigger(root *BinaryTree, key int32, results *[]*Integer) {
    //...
    bigger(root.left, key, results)
    //...
}
resultsはすでにポインタとして渡されているので、再帰呼び出しにresultsをそのまま渡しても、resultsが指すスライスの実体は同じものを指し続けます。

逆に、もしアドレスオペレータ&を使用した場合：

go
Copy code
func bigger(root *BinaryTree, key int32, results *[]*Integer) {
    //...
    bigger(root.left, key, &results)
    //...
}
これはコンパイルエラーになります。なぜなら、&resultsは**[]*Integer（ポインタのポインタ）を表し、関数biggerは*[]*Integerを期待しているからです。なので、&を使用する必要はありません。

基本的に、Go言語においてスライスやマップを関数に渡す場合、そのデータを変更する意図があるのであればポインタを使用することがあります。一方で、配列、構造体、整数、浮動小数点数などを関数に渡す場合、そのデータを変更する意図があるならばポインタを使用します。そしてポインタが渡された場合、再帰などの中でそのポインタをそのまま渡すことで、同じメモリアドレスを指すことになります。

再帰のプロセスについて</br>
>はい、その通りです。以下のベースケースにより、再帰の終了点（最後の関数）を確認することができます。

go
Copy code
if root == nil || root.data == nil {
    fmt.Println("a", root)
    return
}
ここでのreturnステートメントは、rootがnilまたはroot.dataがnilの場合に、これ以上の処理（子ノードへの再帰呼び出しやデータの追加）を行わず、直ちに関数から抜け出すことを意味します。これはベースケースとなり、再帰の一連の呼び出しが「最後」であることを示すものと言えます。

このベースケースがないと、nilノードにアクセスしてしまい、ランタイムエラーが発生します。再帰呼び出しの際には特に、このようなベースケースを適切に設定し、エラーを防ぐことが重要となります。

上記のfmt.Println("a", root)はデバッグ用の出力で、returnが実行されたタイミングでどのrootがnilであったかをログとして残す役割を果たします。これを用いることで、関数の動きやベースケースがどのような状況で呼び出されるかを確認することができます。