# report
https://recursionist.io/dashboard/course/3/lesson/471
```go
 results = postorderTraversalHelper(root.left,results)
    fmt.Println("左探索",results,root.data.value)
    results = postorderTraversalHelper(root.right,results)
    fmt.Println("右探索",results,root.data.value)
    results = append(results,root.data.value)
    return results
```

    https://recursionist.io/dashboard/problems/submissions/681635
このコードでは左を探索しても右のコードで上書きされず継続されるのはresultsを引数に渡しているから、
一方下記はresultを関数の引数で保持していないため上書きされる。
```go
if root.left != nil && root.left.data != nil {
    result = totalEvenGrandparent(root.left)
    iterator = root.left
}
if root.right != nil && root.right.data != nil {
    result = totalEvenGrandparent(root.right)
    iterator = root.right
}
```
https://recursionist.io/dashboard/problems/submissions/681704

スライスではなく整数型の値を追加していきたい。上書きせずに継続するには+=。=だけだと新しいresultsがコールされる関数ごとに作られて初期化される。仮に、resultsを再帰の引数にしていたのならば=で引き継ぎできた。逆に+=だと自己参照して2回たしてしまう。(https://recursionist.io/dashboard/problems/submissions/681717)
```go
    if node.left != nil && node.left.data != nil {
    
        grandParent := findParent(root, findParent(root, node.left))
        
        if grandParent != nil && grandParent.data.value % 2 == 0 {
            fmt.Println("grandParent-l",grandParent.data.value)
            result += node.left.data.value
        }
        result += totalEvenGrandparentHelper(root,node.left)
    }

```

反省点
・問題文を読み損ねて時間ロス（二分探索木だとおもってたがただの二分木だったためfindParent関数を実装し損ねた。）
・再帰で返す値が、スライスかただの値か、返すときに引数に渡せるか渡せないかに留意すべきだった。


探索の再帰呼び出しと加算の処理は独立しているので順序は問わない。
>このアプローチがうまくいく一因としては、各ノードでの処理（祖父ノードの確認と値の加算）が、そのノードの子孫に対する処理とは独立しているためです。つまり、ノードの値を加算するタイミング（子ノードの再帰呼び出しの前か後か）が結果に影響を与えないのです。
```go
    if node.right != nil && node.right.data != nil {
        grandParent := findParent(root, findParent(root, node.right))
        result += totalEvenGrandparentHelper(root,node.right)
        if grandParent != nil && grandParent.data.value % 2 == 0 {
            fmt.Println("grandParent-r",grandParent.data.value)
            result += node.right.data.value
        }
        
    }
```

>grandParentの再代入さえあれば他の２つのresultは互いに独立ということですね
ChatGPT
はい、正確にはその通りです。grandParentの再代入（またはチェック）はそのノードに関する局所的な処理であり、resultに対する2つの加算操作：

result += node.left.data.value または result += node.right.data.value
result += totalEvenGrandparentHelper(root,node.left) または result += totalEvenGrandparentHelper(root,node.right)
は互いに独立しています。なぜならば、一つ目の加算は直接そのノード（とその祖父ノード）に関連していて、二つ目の加算はそのノードの子孫に関連しているからです。これらの処理は互いに影響を与えないので、どちらを先に実行しても結果は変わりません。

これは、1つ目の加算でresultが変更されたとしても、そのresultの値は2つ目の再帰呼び出しの処理やその結果には影響を与えない、ということを意味します。同様に、2つ目の加算がどれだけresultを変更しても、それが1つ目の加算に影響を与えることはありません。

そのため、grandParentの再代入やチェックを正確に行う限り、2つのresultへの加算操作は互いに独立していて、どちらを先に実行しても最終的なresultの値は同じになります。