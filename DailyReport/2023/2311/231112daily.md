# done
Recursion データベース</br>
データベースシステム
・データベースの内部（１）</br>
・データベースの内部（２）</br>
・データベースアーキテクチャ（１）</br>
・データベースアーキテクチャ（２）</br>
・データベースモデル</br>
・Quiz2</br>
関係モデル</br>
・関係モデル</br>
・関係（１）</br>
・関係（２）</br>
・参照関係（１）</br>
・参照関係（２）</br>
・参照関係（３）</br>
・参照関係（４）</br>
・Quiz3</br>
・関係と関数（１）</br>


# report
### CRUD
>SQL のような言語では、INSERT（作成）、SELECT（読み込み）、UPDATE、DELETE の各コマンドが使われます。

### DDL/DML
>データベース言語は、データ定義言語 DDL（data-definition language）、データ操作言語 DML（data-manipulation language）の 2 つの独立したサブ言語から構成されています。

### スキーマ
>スキーマ（schema）とは、保存されているデータの集合体に紐付けられる全ての規則のことを指します。

>スキーマには、格納するデータ型、使用する物理的データ構造（上級ユーザー向け）、データエントリの整合性と制約、および承認ルールの宣言が含まれます。つまり、スキーマはどのようなデータをデータベースに入れることができるか、どのようにデータベースに保存するか、誰がデータベースにデータを保存したり読み出したりできるかを決定します。これらのルールや設定は全て、データベース自身だけがアクセスできるメタデータを持つデータ辞書（data dictionary）に含まれます。

>データベースの設計をスキーマと呼ぶのに対し、ある特定の時点でのシステム内に存在する実際のデータをインスタンス（instance）といいます。プログラミング、特に OOP の観点からは、スキーマは「クラスの設計図」、データベースのインスタンスは「ある時点で特定の状態にあるオブジェクト（クラスのインスタンス）」と考えることができるでしょう。例えば、バックアップを作成する際には、その時点でのスキーマ（構造）とデータベースのインスタンスがエクスポートされます。

### クエリプロセッサモジュール
>クエリプロセッサ（query processor）モジュールは、データベース言語を解釈し、低階層の命令にコンパイルする役割を担っています。

>クエリプロセッサモジュールの中には、DDL 文を実行し、それに応じてデータ辞書を更新する DDL インタープリタ（DDL interpreter）と、クエリを最適化し、さらに低階層の命令に変換して、クエリ評価エンジンで処理する DML コンパイラ（DML compiler）があります。

### ストレージマネージャ
>バイナリファイルのようにオペレーティングシステム階層でコンピュータに保存されているものと、クエリプロセッサが生成する命令との間をつなぐ役割を担うストレージマネージャ（storage manager）

>ストレージマネージャは、オペレーティングシステムの低階層 I/O API（Input/Output API）と通信することで、データをコンピュータ内のファイルとして保存する役割を果たします。ストレージマネージャは、データ辞書にアクセスしてデータベース管理者が微調整したデータベースの構造を把握し、整合性と権限のチェックを行うことができます。

>ストレージマネージャは、データに素早くアクセスできるルックアップテーブルのように、インデックスのセットを管理することができます。

```sql
Authorization manager
ユーザーがデータにアクセスする権限を持っているかどうかを、データベースのデータ辞書を参照してチェックします。


Integrity manager
状態の変更がスキーマで指定された制約と参照の整合性に従うかどうかをチェックします。


File manager
ディスクストレージ内のデータの構造を決定し、ディスクストレージ内のデータの割り当てを行います。


Buffer manager
メインメモリーに何をキャッシュするかを決定し、ディスクからメインメモリーへのデータの取り込みを行います。


Transaction manager
データベースのトランザクション内で必要な手続きを行います。これには、同時実行時の一貫性の維持、ロールバックの仕組み、原子性のルールの適用等が含まれます。リレーショナルデータベースでは、ACID （原子性、一貫性、独立性、永続性） ルールが適用されます。
```

### データベースの階層
```java
物理層（physical level）

データが物理的にどのように保存されるかを決定します。この階層では、次のような質問があります。

データ型は何バイトか？
ファイル内の記号を解析する際、区切り文字は必要か？
使用すべきデータ構造は何か？
何をどのような方法でインデックス化するか？
論理層（logical level）

スキーマ設計のように、データベースが高階層でどのように構成されているかを表します。この階層では、次のような質問があります。

テーブル（データ集）にはどのようなデータ型を束ねるべきか？
制約や整合性のルールは何か？
他のテーブルのキーなど、参照すべきものはあるか（外部キー等）？
データベース全体のデータ関係はどうなっているか？
外部層（view level）

データベースの一部分のみを表します。外部層はデータベース管理者が設定するもので、セキュリティ上の目的や複雑度を軽減するためのものです。アプリケーションの一部や開発者は、大規模なアプリケーションのデータベース設計全体のうち、ごく一部だけを知っていれば問題ありません。
```

### データ辞書
>これらのルールや設定は全て、データベース自身だけがアクセスできるメタデータを持つデータ辞書（data dictionary）に含まれます

### データベースモデル
関係モデル（relational model
実態関連データモデル(entity-relationship data model)
半構造化データモデル(semi-structrured data model)
オブジェクトモデル（object model）

```sql
オブジェクトモデルは多くの場合関係モデルと共存しますか？
ChatGPT
はい、オブジェクトモデルはしばしば関係モデルと共存します。これは特に、オブジェクトリレーショナルデータベース管理システム（ORDBMS）で顕著です。ORDBMSは、関係モデルの堅牢さとオブジェクト指向プログラミングの柔軟性を組み合わせたシステムです。

この種のデータベースシステムでは、オブジェクト指向の特徴（例えば、継承、ポリモーフィズム、複合データタイプ）が、従来の関係データベースの機能（例えば、テーブル、行、列、SQLクエリ）と一緒に提供されます。これにより、開発者は複雑なデータ型をより自然に表現することができ、データベースに格納されるオブジェクトがアプリケーションのオブジェクトとより密接にマッピングされるようになります。

また、アプリケーション開発においては、オブジェクトリレーショナルマッピング（ORM）ツールがよく使用されます。ORMは、オブジェクトモデルと関係モデルとの間にあるミスマッチを解決するための技術です。ORMを使うと、プログラマはオブジェクト指向の言語で書かれたコードを、関係データベースに保存されたデータと透過的にやり取りできるようになります。

したがって、オブジェクトモデルと関係モデルの共存は、モダンなソフトウェア開発において一般的な実践です。
```

### 関係代数
>関係モデルの語源は、関係代数（relational algebra）という用語に由来しています。関係と呼ばれるデータの集合を定義し、関係を入出力とする関数を定義する数学理論のことを関係代数といいます。これらの関数を使うと、関係を入力として取り込み、述語と一定の操作を行うことによって、関係を変換することができます。

### キー
>関係の中で、キー（key）とは、関係内のタプルを一意に識別するために使用される、属性または属性の集合のことを指します。

>関係の数学的な定義に戻ると、関係とはタプルの集合であり、全く同じ属性値を持つタプルは存在しません。これはタプルの全ての属性をスーパーキーとして使い、タプルを識別することができることを意味します。スーパーキー（super key）とは、関係内でタプルを一意に識別することができる任意のキーです。タプルの全ての属性は、タプルを識別することができるので、定義上はスーパーキーになります。

>スーパーキーは不要な属性を含んだ属性の集合になっていることがあります。属性が一つでも欠けると一意に識別できなくなる属性の集合を候補キー（candidate key）といいます。1 つの関係は複数の候補キーを持つことができます。


>タプルの識別に最も好ましいものとして、設計者や開発者にとって選択される候補キーを主キー（primary key）といいます。関係に存在する候補キーが 1 つしかない場合、その候補キーは主キーとなります。

>良い主キーは、値が変更されることがないと予想される属性であり、ここでは、user_id を主キーとして選択されるべきです。

###　参照整合性制約
参照整合性制約とは別に外部キー制約というのがある。</br>
参照整合性制約は外部キー制約を含む</br>

>データベースシステムは、外部キーが正しいことを確認するために整合性チェックを行います。外部キー制約が主キーに結びついているのに対し、より緩いバージョンとして参照整合性制約（referential integrity constraint）があります。
```sql
参照整合性制約は参照するタプルの主キーである必要はなくタプルに存在しさえしてればいい？
ChatGPT
はい、その通りです。参照整合性制約は、外部キーが参照する値が関連するテーブルのタプルに存在することを保証するものですが、必ずしも主キーである必要はありません。ただし、通常は主キーや候補キー（そのテーブル内で一意の値を保持する属性のセット）が使用されます。

具体的には、参照されるテーブルにおいて、外部キーが指し示す列は一意の値を持つ必要があります。これは通常、主キーまたはユニーク制約がある列によって保証されます。これにより、データの一貫性が維持され、不正なデータが挿入されることを防ぎます。

たとえば、employee テーブルの department_id 列が department テーブルの id 列を参照する外部キーだとしたら、department テーブルの id 列にはユニーク制約（一意性制約）が設定されている必要がありますが、それが主キーであるかどうかは必須ではありません。重要なのは、参照される側の id 値がユニークであることです。


```

### タプル
>問題2: データベースにおいて、固定サイズのデータのリストを（　　）という。
>あなたの回答：タプル

```javascript
// select演算子
let select = (predicateF, relation) => relation.filter(predicateF);

// predicateF
let f = predicate => tuple => predicate(tuple);

// 1- ユーザー名が 10 文字以上の全てのユーザーを検索します。
console.log( "----例1----" );
let task1 = select(f(x => x.userName.length >= 10), userRelation);
```

```
JavaScriptの relation.filter(predicateF) において、relation は配列のことで、配列に含まれる各要素（この場合はユーザーオブジェクト）を predicateF 関数に渡して、条件に合う要素だけを選択して新しい配列を作成します。

ここでの tuple は、配列 relation の各要素を指します。つまり、relation の中の一つ一つのユーザーオブジェクトが tuple に相当します。filter メソッドはこの tuple（ユーザーオブジェクト）を一つずつ predicateF に渡し、その関数が true を返したものだけを集めた新しい配列を作ります。
```
### javascriptのラムダ式

```javascript
 userName の長さが10文字以上かどうかをチェックする新しい関数を返します。しかし、この新しい関数はまだ userRelation 配列の各要素に適用されていません。

とありますがlet f = predicate => tuple => predicate(tuple)とあるようにfは最終的にpredicate(tuple)となるのでは？この最終形になるにはselect関数にfを引数としてわたさないといけないのか？
ChatGPT
ご質問のポイントを理解しました。f が返す関数自体は predicate(tuple) という形を取りますが、これはまだ実際に配列の要素に適用されているわけではありません。この関数は、単に与えられた述語（predicate）を配列の各要素（tuple）に適用するためのものです。

f は高階関数であり、述語関数を取り、その述語を実行する別の関数を返します。しかし、この返された関数はまだ実行されていません。それを実行するためには、何らかの形で配列の要素に適用する必要があります。

select 関数は、f が生成した述語関数を配列の各要素に適用し、その述語関数が true を返す要素だけを集めて新しい配列を作るために使われます。select 関数は、filter メソッドを呼び出すことによって、述語関数を配列の各要素に適用します。

以下の行において：

javascript
Copy code
let ex5 = select(f(x => x.autherId == 1), pageRelation);
ここで select は、f によって生成された述語関数を pageRelation 配列の各要素に適用し、autherId が 1 に等しい要素だけを選択しています。このプロセスは、配列の filter メソッドを使って実行されます。select 関数に f と pageRelation を渡すことで、述語関数を pageRelation 配列の要素に適用し、条件にマッチする要素のみを抽出することができます。
```

```
let fはselect関数を介して渡された時のみtupleやpredicate(tuple)の関数を出力できる？単独でf関数をたとえばf(x => x.userName.length >= 10)としてもtupleとなる配列要素がないので機能しない？
ChatGPT
はい、その通りです。f 関数自体は述語を取り、それを適用するための新しい関数を返しますが、それ自体では配列に適用されていません。f が単独で使用されるとき、それは単に関数を返すだけで、実際に配列の要素に適用されるわけではありません。

たとえば、以下のようなコードがあるとします。

javascript
Copy code
let f = predicate => tuple => predicate(tuple);
let predicateFunction = f(x => x.userName.length >= 10);
このコードでは、predicateFunction は f によって生成された新しい関数ですが、まだ userRelation 配列やその他の配列には適用されていません。この関数を配列の要素に適用するには、.filter() メソッドを直接使うか、select 関数に渡す必要があります。

例えば、以下のようにして配列に適用することができます。

javascript
Copy code
let result = userRelation.filter(predicateFunction);
または select 関数を介して適用する場合は、以下のようになります。

javascript
Copy code
let result = select(predicateFunction, userRelation);
select 関数は内部で .filter() メソッドを呼び出しており、predicateFunction を配列の各要素に適用し、条件に合致する要素だけを含む新しい配列を生成します。




User
let f = predicate => tuple => predicate(tuple);
let predicateFunction = f(x => x.userName.length >= 10);
ここではfはどのような関数が生成されているのですか？predicate,tuple,predicate(tuple)にあたるのはなにになる？
ChatGPT
このコードでは、f は高階関数です。つまり、別の関数を引数として受け取り、新しい関数を返す関数です。predicate は真偽値を返す関数（述語関数）です。tuple はこの場合、配列やリストの中の個々の要素、つまりコンテキストによってはオブジェクトや値などを指します。

f の定義は、predicate 関数を引数として受け取り、その述語を適用する新しい関数を生成して返すというものです。predicate 関数は tuple に適用されるべき何らかの条件をチェックする関数です。

次の行である let predicateFunction = f(x => x.userName.length >= 10); は、f を使って、ユーザー名の長さが10文字以上かどうかをチェックする述語関数を生成しています。

ここでの predicate は (x => x.userName.length >= 10) になります。これは tuple （この場合はユーザーオブジェクト）を引数として受け取り、userName プロパティの長さが10以上かどうかを評価する関数です。

そして、predicate(tuple) は、上記の述語関数に具体的な tuple （ユーザーオブジェクト）を適用した結果、つまり具体的なユーザーオブジェクトの userName プロパティが10文字以上かどうかの真偽値を返す関数です。

したがって、predicateFunction は、ユーザーオブジェクトを引数として取り、その userName プロパティの長さが10文字以上であれば true、そうでなければ false を返す関数です。この関数は後で userRelation などの配列に .filter() メソッドを使って適用することができます。





```